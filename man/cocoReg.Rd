% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cocoReg.R
\name{cocoReg}
\alias{cocoReg}
\title{cocoReg}
\usage{
cocoReg(
  type,
  order,
  data,
  xreg = NULL,
  seasonality = c(1, 2),
  constrained.optim = TRUE,
  b.beta = -10,
  start = NULL,
  start.val.adjust = TRUE,
  method_optim = "Nelder-Mead",
  replace.start.val = 1e-05,
  iteration.start.val = 0.99,
  method.hessian = "Richardson",
  cores = 2
)
}
\arguments{
\item{type}{character string indicating the type of model to be fitted}

\item{order}{integer vector indicating the order of the model}

\item{data}{time series data to be used in the analysis}

\item{xreg}{optional matrix of explanatory variables for use in a regression model}

\item{seasonality}{integer vector indicating the seasonal component of the model}

\item{constrained.optim}{logical indicating whether optimization should be constrained}

\item{b.beta}{numeric value indicating the lower bound for the parameters of the explanatory variables for the optimization}

\item{start}{optional numeric vector of starting values for the optimization}

\item{start.val.adjust}{logical indicating whether starting values should be adjusted}

\item{method_optim}{character string indicating the optimization method to be used}

\item{replace.start.val}{numeric value indicating the value to replace any invalid starting values}

\item{iteration.start.val}{numeric value indicating the proportion of the interval to use as the new starting value}

\item{method.hessian}{character string indicating the method to be used to approximate the Hessian matrix}

\item{cores}{numeric indicating the number of cores to use}
}
\value{
output of the regression analysis
}
\description{
The function \code{cocoReg} fits first and second order (Generalized) Poisson #'  Autoregressive (G)PAR models presented in (Jung and Tremayne, 2010). Lags enter the
 process via a random operator that accounts for the count structure of the data (Joe, 1996). The models can be thought of as
 stationary Markov chains of finite order, where the distribution of the innovations can
 either be Poisson or Generalized Poisson.

 Maximum likelihood is used for estimation and the user can choose to include linear
 constraints or not. If linear constraints are not included, it cannot be guaranteed that
 the parameters will lie in the theoretically feasible parameter space, but the
 optimization process will be faster.

 The function uses method of moments estimators to obtain starting values for the numerical
 optimization, but the user can also specify their own starting values if desired.
}
\details{
\emph{General introduction to the methods with formulas (math-heaviest part of the vignette)}

Let a time series of counts be \eqn{\{X_t\}}, a random operator be \eqn{R(\cdot)}, the relevant past history of \eqn{X_t} be \eqn{\mathcal{F}_{t-1}} and \eqn{W_t} be i.i.d discrete innovations. The general model is of the form
\deqn{X_t = R(\mathcal{F}_{t-1}) + W_t.}
For first-order and second-order models the relevant past history depends on the model's order and is defined by \eqn{\mathcal{F}_{t-1} = X_{t-s_1}} and \eqn{\mathcal{F}_{t-1} = (X_{t-s_1}, X_{t-s_2})}, respectively. \eqn{s_1} < \eqn{s_2} are the parameters indicating the degree of stochastic seasonality.
The innovations follow either a Poisson or a generalized Poisson distribution. Such that either \eqn{W_t \sim Pois(\lambda_t)} or \eqn{W_t \sim GP(\lambda_t, \eta)}.
If no covariates are used \eqn{\lambda_t = \lambda} and if covariates are used \deqn{\lambda_t = \exp{\left(\beta_0 + \sum_{j = 1}^p \beta_j \cdot y_{t,j} \right)},} whereby \eqn{y_{t,j}} is the \eqn{j}-th covariate at time \eqn{t}.
Standard errors are computed by the square root of the diagonal elements of the inverse hessian.
}
\examples{
## GP2 model without covariates
length <- 1000
par <- c(0.5,0.2,0.05,0.3,0.3)
data.sim <- cocoSim(order = 2, type = "GP", par = par, length = length)
data <- data.sim$data
fit <- cocoReg(order = 2, type = "GP", data = data)

##Poisson1 model with covariates
length <- 1000
period <- 50
sin <- sin(2*pi/period*(1:length))
cos <- cos(2*pi/period*(1:length))
cov <- cbind(sin, cos)
par <- c(0.2, 0.2, -0.2)
data.sim <- cocoSim(order = 1, type = "Poisson", par = par, xreg = cov, length = length)
data <- data.sim$data
fit <- cocoReg(order = 1, type = "Poisson", data = data, xreg = cov)
}
\references{
Jung, R. C. and Tremayne, A. R. (2010) Convolution-closed models for count timeseries with applications. \emph{Journal of Time Series Analysis}, \bold{32}, 3, 268--280.

Joe, H. (1996) Time series models with univariate margins in the convolution-closed infinitely divisible class. \emph{Journal of Applied Probability}, 664--677.
}
\author{
Manuel Huth
}
